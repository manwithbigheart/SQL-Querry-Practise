<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Definitive SQL Tutor</title>
    <style>
        :root {
            --primary-color: #4A90E2; /* A more professional blue */
            --secondary-color: #50E3C2; /* A fresh mint green */
            --success-color: #7ED321; /* A vibrant green */
            --warning-color: #F5A623; /* A friendly orange */
            --text-color: #4A4A4A;
            --light-text-color: #9B9B9B;
            --bg-color: #F7F9FB;
            --container-bg: #FFFFFF;
            --border-color: #EAEAEA;
            --code-bg: #FDFDFD;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.07);
            --font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        *, *::before, *::after { box-sizing: border-box; }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 40px 20px;
            margin: 0;
        }

        .main-container {
            width: 100%;
            max-width: 900px;
            background: var(--container-bg);
            border-radius: 20px;
            box-shadow: var(--shadow);
            padding: 40px 50px;
            transition: opacity 0.3s ease-in-out;
        }

        h1, h2 {
            text-align: center;
            margin-top: 0;
        }
        h1 { color: var(--primary-color); font-weight: 600; }
        h2 { color: var(--primary-color); border-bottom: none; padding-bottom: 0; }

        /* --- Topic Selection View --- */
        #topic-selection-view { animation: fadeIn 0.5s; }
        #topic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin-top: 40px;
        }
        .topic-card {
            background: var(--container-bg);
            padding: 25px;
            border: 1px solid var(--border-color);
            border-radius: 15px;
            text-align: center;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        .topic-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        /* --- Practice View --- */
        #practice-view { display: none; }
        .practice-card {
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 25px;
            background-color: var(--container-bg);
        }
        .task-description { font-size: 1.25em; font-weight: 500; margin-bottom: 20px; line-height: 1.6; }
        
        #user-query-area {
            width: 100%;
            height: 160px;
            font-family: "Fira Code", "Courier New", monospace;
            font-size: 1em;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-sizing: border-box;
            margin-bottom: 15px;
            resize: vertical;
            background-color: var(--code-bg);
        }
        
        /* --- Feedback Styles --- */
        #feedback-container {
            border-radius: 10px;
            margin-top: 20px;
            padding: 20px;
            display: none;
            animation: fadeIn 0.4s;
        }
        #feedback-container.correct { background-color: #e4f8d3; border: 1px solid var(--success-color); }
        #feedback-container.incorrect { background-color: #fff8e8; border: 1px solid var(--warning-color); }
        #feedback-container h4 { margin-top: 0; font-size: 1.1em; }
        #feedback-list { list-style-type: none; padding-left: 0; margin: 0; }
        #feedback-list li { margin-bottom: 10px; display: flex; align-items: flex-start; gap: 10px; }
        
        pre {
            background-color: #F4F7F9;
            padding: 20px;
            border-radius: 10px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: "Fira Code", "Courier New", monospace;
            border: 1px solid var(--border-color);
            font-size: 1em;
        }

        .explanation {
            background-color: #e9f5ff;
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid var(--primary-color);
            font-size: 1em;
            line-height: 1.7;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            letter-spacing: 0.5px;
        }
        .btn:hover { transform: translateY(-3px); box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .btn-primary { background: linear-gradient(45deg, var(--primary-color), #3675C5); }
        .btn-success { background: linear-gradient(45deg, var(--success-color), #6ABF1A); }
        .btn-secondary { background: #9B9B9B; }
        .btn-info { background: linear-gradient(45deg, var(--secondary-color), #48C6A9); }
        
        .action-buttons { display: flex; justify-content: center; flex-wrap: wrap; gap: 20px; margin-top: 20px; }
        .navigation-controls { display: flex; justify-content: space-between; align-items: center; }

        /* --- Progress Bar --- */
        .progress-bar-container {
            background-color: var(--border-color);
            border-radius: 10px;
            height: 10px;
            width: 100%;
            margin: 15px 0 25px;
        }
        #progress-bar {
            background-color: var(--primary-color);
            height: 100%;
            border-radius: 10px;
            width: 0%;
            transition: width 0.4s ease-in-out;
        }

        /* --- Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s ease;
            z-index: 100;
        }
        .modal-overlay.show { opacity: 1; visibility: visible; }
        .modal-content {
            background: var(--container-bg);
            padding: 40px;
            border-radius: 20px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            transform: scale(0.9);
            transition: transform 0.4s ease;
        }
        .modal-overlay.show .modal-content { transform: scale(1); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; }
        .modal-header h3 { margin: 0; color: var(--primary-color); font-size: 1.8em; }
        .modal-close { font-size: 2em; font-weight: bold; cursor: pointer; color: #aaa; border: none; background: none; }
        .modal-body { margin-top: 25px; line-height: 1.8; font-size: 1.05em; }
        .modal-body ul { list-style-type: none; padding-left: 0; }
        .modal-body li { padding-left: 1.5em; margin-bottom: 1.2em; position: relative; }
        .modal-body li::before {
            content: 'ðŸ”¹';
            position: absolute;
            left: 0;
            color: var(--primary-color);
        }
        .modal-body strong { color: var(--primary-color); }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>

    <div class="main-container">

        <div id="topic-selection-view">
            <h1>SQL Smart Tutor âœ¨</h1>
            <div id="topic-grid"></div>
        </div>

        <div id="practice-view">
            <div class="navigation-controls">
                 <button id="back-to-topics-btn" class="btn btn-secondary" style="background:#ddd; color:#555;">&larr; Topics</button>
                 <button id="toggle-concepts-btn" class="btn btn-info">ðŸ“š Read Key Concepts</button>
            </div>
            <h2 id="topic-title"></h2>
            <div class="progress-bar-container"><div id="progress-bar"></div></div>

            <div class="practice-card">
                <p id="question-counter" style="text-align:right; font-weight:bold; color:var(--light-text-color);"></p>
                <h3>Schema:</h3>
                <pre id="schema-display"></pre>
                <p class="task-description" id="task-description"></p>
                
                <label for="user-query-area"><strong>Your SQL Code:</strong></label>
                <textarea id="user-query-area" placeholder="Write your SQL query here..."></textarea>
                <button id="check-code-btn" class="btn btn-success" style="width:100%;">Analyze My Code</button>
                
                <div id="feedback-container">
                    <h4 id="feedback-title"></h4>
                    <ul id="feedback-list"></ul>
                </div>

                <div class="action-buttons">
                    <button id="reveal-answer-btn" class="btn btn-primary">Show Correct Answer</button>
                </div>
                
                <div id="answer-content" class="reveal-content">
                    <h3>Correct Query:</h3>
                    <pre id="query-code"></pre>
                    <h3>Explanation:</h3>
                    <div class="explanation" id="explanation-text"></div>
                </div>
            </div>
            <div class="navigation-controls" style="justify-content:center; gap: 20px;">
                <button id="prev-btn" class="btn btn-secondary">Previous</button>
                <button id="next-btn" class="btn btn-secondary">Next</button>
            </div>
        </div>

    </div>
    
    <div id="concepts-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title"></h3>
                <button id="modal-close-btn" class="modal-close">&times;</button>
            </div>
            <div id="modal-body" class="modal-body"></div>
        </div>
    </div>

    <script>
        const learningData = [
            {
                topic: "Set 1: Joins (Basic)",
                schema: "- students(student_id, name, course_id)\n- courses(course_id, course_name)",
                concepts: [
                    "<strong>Purpose of Joins:</strong> At their core, joins are used to combine rows from two or more tables based on a related column between them. This allows you to retrieve a consolidated set of data that spans multiple tables.",
                    "<strong>INNER JOIN:</strong> This is the most common join. It returns only the records that have matching values in <strong>both</strong> tables. Think of it as the intersection of two sets. If a student has a `course_id` that doesn't exist in the `courses` table, they won't appear in the result.",
                    "<strong>LEFT JOIN (or LEFT OUTER JOIN):</strong> This join returns <strong>all</strong> records from the left table (the one mentioned first), and only the matched records from the right table. If there's no match for a row from the left table, the columns from the right table will contain `NULL`. This is perfect for finding things that don't have a corresponding entry, like students not enrolled in any course.",
                    "<strong>The ON Clause:</strong> This is the crucial part of a join that defines the relationship. You must specify which columns from each table should be matched (e.g., `ON students.course_id = courses.course_id`).",
                    "<strong>Table Aliases:</strong> Using aliases (like `s` for `students` and `c` for `courses`) makes your queries shorter, more readable, and is essential for more complex joins, especially self-joins."
                ],
                questions: [
                    { task: "1. Write a query using an INNER JOIN to display all students along with their course names.", query: "SELECT s.student_id, s.name, c.course_name FROM students s INNER JOIN courses c ON s.course_id = c.course_id;", explanation: "An `INNER JOIN` returns only the rows where the join condition is met in both tables. Here, it retrieves students who are enrolled in a course, matching `students.course_id` with `courses.course_id`. Students without a course are excluded." },
                    { task: "2. Write a query using a LEFT JOIN to display all students and their course names, including students who have not enrolled in any course.", query: "SELECT s.student_id, s.name, c.course_name FROM students s LEFT JOIN courses c ON s.course_id = c.course_id;", explanation: "A `LEFT JOIN` returns all rows from the left table (students) and the matched rows from the right table (courses). If a student is not enrolled in a course, the `course_name` will appear as `NULL`." }
                ]
            },
            {
                topic: "Set 2: Aggregation & Group By",
                schema: "- orders(order_id, customer_id, order_date, total_amount)\n- customers(customer_id, customer_name, city)",
                concepts: [
                    "<strong>Aggregate Functions:</strong> These functions operate on a set of rows to return a single, summary value. The most common are `COUNT()` (counts rows), `SUM()` (sums values), `AVG()` (calculates average), `MAX()` (finds the maximum value), and `MIN()` (finds the minimum value).",
                    "<strong>GROUP BY Clause:</strong> This clause is the cornerstone of aggregation. It collapses multiple rows into a single summary row based on column values. The aggregate functions then operate on each of these groups. You must group by all non-aggregated columns in your `SELECT` list.",
                    "<strong>HAVING vs. WHERE:</strong> This is a critical distinction. `WHERE` filters rows <strong>before</strong> any grouping or aggregation happens. `HAVING` filters the groups themselves <strong>after</strong> the aggregation has been performed. You use `HAVING` to place conditions on the output of aggregate functions (e.g., `HAVING SUM(total_amount) > 1000`).",
                    "<strong>Logical Order of Operations:</strong> The database logically processes a query in this order: `FROM` & `JOIN` -> `WHERE` -> `GROUP BY` -> `HAVING` -> `SELECT` -> `ORDER BY` -> `LIMIT`. Understanding this order is key to writing complex queries correctly."
                ],
                questions: [
                    { task: "1. Write a query to display the total amount spent by each customer.", query: "SELECT c.customer_id, c.customer_name, SUM(o.total_amount) AS total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.customer_name;", explanation: "`SUM()` is an aggregate function that calculates the total. `GROUP BY` is used to group rows that have the same values in specified columns into summary rows. Here, we sum the `total_amount` for each unique customer." },
                    { task: "2. Write a query to find the city with the highest number of customers.", query: "SELECT city, COUNT(customer_id) AS total_customers FROM customers GROUP BY city ORDER BY total_customers DESC LIMIT 1;", explanation: "This query first groups customers by `city` and counts them using `COUNT()`. Then, `ORDER BY ... DESC` sorts the cities from the highest customer count to the lowest. Finally, `LIMIT 1` retrieves only the top row." }
                ]
            },
            {
                topic: "Set 3: Subqueries",
                schema: "- employees(emp_id, emp_name, dept_id, salary)\n- departments(dept_id, dept_name)",
                concepts: [
                    "<strong>Definition:</strong> A subquery (also called an inner query or nested query) is a complete `SELECT` statement that is nested inside another SQL statement. It's a powerful way to break down complex problems.",
                    "<strong>Scalar Subquery:</strong> This is the simplest type. It returns a single value (one row and one column). You can use it anywhere a single literal value would be appropriate, such as in a `WHERE` clause for comparison (e.g., `WHERE salary > (subquery)`).",
                    "<strong>Multi-row Subquery:</strong> This type returns a list of values (multiple rows, one column). It must be used with operators that can handle lists, such as `IN`, `NOT IN`, `ANY`, or `ALL`.",
                    "<strong>Correlated Subquery:</strong> This is an advanced type where the inner query depends on the outer query for its values. The inner query is executed once for every row processed by the outer query. While powerful, they can be inefficient and should be used with care; often, a `JOIN` is a better-performing alternative."
                ],
                questions: [
                    { task: "1. Write a query to find the employees who earn more than the average salary of all employees.", query: "SELECT emp_id, emp_name, salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);", explanation: "A subquery is nested inside another query. Here, the inner query `(SELECT AVG(salary) FROM employees)` calculates the average salary first. The outer query then uses this single value to filter for employees whose salary is greater than that average." },
                    { task: "2. Write a query to display the department name of the highest paid employee.", query: "SELECT d.dept_name FROM employees e JOIN departments d ON e.dept_id = d.dept_id WHERE e.salary = (SELECT MAX(salary) FROM employees);", explanation: "The subquery `(SELECT MAX(salary) FROM employees)` finds the highest salary value. The outer query then finds the employee(s) with that exact salary and joins with the departments table to retrieve their department's name." }
                ]
            },
            {
                topic: "Set 4: Window Functions",
                schema: "- sales(sale_id, product_id, sale_date, amount)\n- products(product_id, product_name, category)",
                concepts: [
                    "<strong>Core Idea:</strong> A window function performs a calculation across a set of table rows that are somehow related to the current row. Unlike a `GROUP BY` aggregation which collapses rows, a window function returns a value for <strong>every single row</strong>.",
                    "<strong>The OVER() Clause:</strong> This is the defining feature of window functions. It specifies the 'window' (the set of rows) for the function to consider. It has two main sub-clauses:",
                    "<strong>PARTITION BY:</strong> This clause divides the rows into logical groups, or partitions. The window function is applied independently to each partition and resets at the boundary of each new partition. It's like a temporary `GROUP BY` that doesn't collapse the rows.",
                    "<strong>ORDER BY:</strong> Within each partition (or across the whole dataset if no partition is specified), this clause sorts the rows. This is crucial for functions that depend on order, like `RANK()`, `LEAD()`, `LAG()`, and running totals.",
                    "<strong>Common Functions:</strong> Use `RANK()`, `DENSE_RANK()`, `ROW_NUMBER()` for ranking. Use `SUM()`, `AVG()`, `COUNT()` over a window for calculations like running totals or moving averages. Use `LEAD()` and `LAG()` to access data from subsequent or preceding rows within the window."
                ],
                questions: [
                    { task: "1. Write a query to display each productâ€™s total sales and also the rank of each product based on total sales.", query: "SELECT p.product_id, p.product_name, SUM(s.amount) AS total_sales, RANK() OVER (ORDER BY SUM(s.amount) DESC) AS sales_rank FROM products p JOIN sales s ON p.product_id = s.product_id GROUP BY p.product_id, p.product_name;", explanation: "`RANK()` is a window function. The `OVER` clause with `ORDER BY SUM(s.amount) DESC` tells it to rank the aggregated sales (calculated via `GROUP BY`) from highest to lowest." },
                    { task: "2. Write a query to find the running total of sales for each product ordered by sale_date.", query: "SELECT product_id, sale_date, amount, SUM(amount) OVER (PARTITION BY product_id ORDER BY sale_date) AS running_total FROM sales;", explanation: "`PARTITION BY product_id` divides the data into groups for each product. The `SUM()` window function then calculates the cumulative sum for each sale within its group, resetting for each new product." }
                ]
            },
             {
                topic: "Set 5: Constraints & Keys",
                schema: "- users(user_id, username, email UNIQUE, created_at)\n- posts(post_id, user_id, post_title, post_date)",
                concepts: [
                    "<strong>Constraints:</strong> These are rules enforced on data columns to ensure the accuracy, reliability, and integrity of the data in the database. They prevent invalid data from being entered.",
                    "<strong>Primary Key:</strong> This is the most important constraint. It uniquely identifies each record in a table. A primary key must contain `UNIQUE` values and cannot contain `NULL` values. A table can have only one primary key, which can consist of single or multiple columns.",
                    "<strong>Foreign Key:</strong> This key is a field in one table that refers to the `PRIMARY KEY` in another table. It is used to create a link between the two tables, enforcing 'referential integrity'. This means you cannot add an order for a customer that doesn't exist.",
                    "<strong>UNIQUE Constraint:</strong> Ensures that all values in a column (or a set of columns) are different. This is perfect for fields like email addresses or usernames that must not be duplicated, but can allow `NULL` values (unlike a primary key).",
                    "<strong>Other Constraints:</strong> `NOT NULL` ensures a column cannot have a `NULL` value. `DEFAULT` provides a default value for a column when none is specified. `CHECK` ensures that the values in a column satisfy a specific condition."
                ],
                questions: [
                    { task: "1. Write a query to create the users table with PRIMARY KEY and email as UNIQUE.", query: "CREATE TABLE users (user_id INT PRIMARY KEY, username VARCHAR(100), email VARCHAR(100) UNIQUE, created_at DATETIME);", explanation: "`PRIMARY KEY` uniquely identifies each record and cannot be null. `UNIQUE` ensures that all values in the email column are different from one another, preventing duplicate accounts." },
                    { task: "2. Write a query to display all users along with the count of posts they created (use GROUP BY).", query: "SELECT u.user_id, u.username, COUNT(p.post_id) AS total_posts FROM users u LEFT JOIN posts p ON u.user_id = p.user_id GROUP BY u.user_id, u.username;", explanation: "A `LEFT JOIN` includes all users, even those with no posts. `COUNT(p.post_id)` correctly counts zero for users with no posts because it only counts non-NULL values. `GROUP BY` aggregates the counts per user." }
                ]
            },
            {
                topic: "Set 6: String & Date Functions",
                schema: "- students(student_id, name, dob, email)",
                concepts: [
                    "<strong>Purpose:</strong> SQL provides a rich set of built-in functions to perform operations on string and date/time data types directly within a query.",
                    "<strong>Common String Functions:</strong> `CONCAT()` (joins strings), `LENGTH()` (gets byte length), `CHAR_LENGTH()` (gets character length), `UPPER()`, `LOWER()`, `SUBSTRING()` (extracts part of a string), `REPLACE()`, `TRIM()` (removes whitespace).",
                    "<strong>Common Date/Time Functions:</strong> `NOW()`, `CURDATE()`, `CURTIME()` to get current timestamps; `DATE_FORMAT()` to format dates into strings; `DATEDIFF()`, `TIMESTAMPDIFF()` to calculate intervals; `DATE_ADD()`, `DATE_SUB()` to add or subtract from dates.",
                    "<strong>Practical Use:</strong> These functions are essential for formatting output, performing calculations (like age), and parsing data stored in a single column into more useful components (like a domain name from an email)."
                ],
                questions: [
                    { task: "1. Write a query to display each studentâ€™s age (use DATEDIFF or TIMESTAMPDIFF).", query: "SELECT student_id, name, TIMESTAMPDIFF(YEAR, dob, CURDATE()) AS age FROM students;", explanation: "`TIMESTAMPDIFF(YEAR, start_date, end_date)` is the ideal function for calculating age as it correctly determines the number of full years that have passed. `CURDATE()` provides the current date to calculate up to today." },
                    { task: "2. Write a query to extract the domain name from email (e.g., gmail.com).", query: "SELECT student_id, name, SUBSTRING_INDEX(email, '@', -1) AS domain FROM students;", explanation: "`SUBSTRING_INDEX(string, delimiter, count)` with a count of -1 is a clever way to return everything *after* the final delimiter. Here, it extracts the part of the email after the '@' symbol." }
                ]
            },
            {
                topic: "Set 7: Advanced Joins",
                schema: "- employees(emp_id, emp_name, manager_id, dept_id)\n- departments(dept_id, dept_name)",
                concepts: [
                    "<strong>SELF JOIN:</strong> A self-join is a regular join, but the table is joined with itself. This is the standard technique for querying hierarchical data (like employees and their managers) stored in a single table. Using table aliases is mandatory to distinguish between the two instances of the table.",
                    "<strong>RIGHT JOIN:</strong> A right join (or right outer join) returns all rows from the right table and the matched rows from the left table. It's the functional opposite of a `LEFT JOIN`. It is useful for ensuring every item from the right table appears in the result, like listing all departments even if they have no employees.",
                    "<strong>CROSS JOIN:</strong> Returns the Cartesian product of the two tables â€“ every row from the first table is combined with every row from the second table. This can produce massive result sets and should be used with caution, usually when you need to generate a complete set of all possible pairings."
                ],
                questions: [
                    { task: "1. Write a query to display each employeeâ€™s manager name using a SELF JOIN.", query: "SELECT e.emp_id, e.emp_name, m.emp_name AS manager_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.emp_id;", explanation: "A `SELF JOIN` joins a table to itself. We use aliases (`e` for employee, `m` for manager) to treat it as two tables, matching an employee's `manager_id` to their manager's `emp_id`. A `LEFT JOIN` is used to include employees who do not have a manager (like the CEO)." },
                    { task: "2. Write a query to display all departments and the number of employees in each department (use RIGHT JOIN).", query: "SELECT d.dept_id, d.dept_name, COUNT(e.emp_id) AS total_employees FROM employees e RIGHT JOIN departments d ON d.dept_id = e.dept_id GROUP BY d.dept_id, d.dept_name;", explanation: "A `RIGHT JOIN` returns all rows from the right table (departments), ensuring that even departments with zero employees are included in the result set, showing a count of 0." }
                ]
            },
            {
                topic: "Set 8: Transactions & ACID",
                schema: "- accounts(account_id, customer_name, balance)",
                concepts: [
                    "<strong>Transaction:</strong> A transaction is a sequence of operations performed as a single, logical unit of work. The entire sequence must complete successfully, or none of the operations are applied. This is the 'all-or-nothing' principle.",
                    "<strong>ACID Properties:</strong> This acronym represents the four key properties that guarantee reliable transaction processing: <ul><li><strong>A</strong>tomicity: All operations within the transaction are completed as a single unit.</li><li><strong>C</strong>onsistency: The database remains in a valid state before and after the transaction.</li><li><strong>I</strong>solation: Concurrent transactions do not interfere with each other, preventing data corruption.</li><li><strong>D</strong>urability: Once a transaction is committed, its changes are permanent, even in the case of system failure.</li></ul>",
                    "<strong>Key Commands:</strong> `START TRANSACTION` (or `BEGIN`) begins a transaction. `COMMIT` saves all the changes made in the transaction to the database. `ROLLBACK` undoes all changes made since the transaction started."
                ],
                questions: [
                    { task: "1. Write SQL commands to start a transaction, transfer â‚¹500 from account_id=1 to account_id=2, and then commit the transaction.", query: "START TRANSACTION;\nUPDATE accounts SET balance = balance - 500 WHERE account_id = 1;\nUPDATE accounts SET balance = balance + 500 WHERE account_id = 2;\nCOMMIT;", explanation: "A transaction bundles operations into an 'all-or-nothing' unit. `START TRANSACTION` begins the process. If both updates succeed, `COMMIT` makes them permanent. If the system crashed after the first update, the transaction would be automatically rolled back on restart, ensuring no money is lost." },
                    { task: "2. Write SQL commands to demonstrate a ROLLBACK after updating a balance.", query: "START TRANSACTION;\nUPDATE accounts SET balance = balance - 1000 WHERE account_id = 1;\nROLLBACK;", explanation: "`ROLLBACK` is the undo command for transactions. It reverts all modifications made since the `START TRANSACTION` command, leaving the database in its original state as if the `UPDATE` never happened." }
                ]
            },
            {
                topic: "Set 9: Indexing & Performance",
                schema: "- orders(order_id, customer_id, order_date, total_amount)",
                concepts: [
                    "<strong>What is an Index?:</strong> An index is a special lookup table that the database search engine can use to speed up data retrieval. It's a performance-tuning feature that works like the index in the back of a book; instead of scanning every page, you look up the topic to find the page number(s) directly.",
                    "<strong>How it Improves Performance:</strong> When you run a query with a `WHERE` clause on an indexed column, the database can use the index to quickly find the exact location of the matching rows, avoiding a 'full table scan' which is very slow on large tables.",
                    "<strong>The Trade-off:</strong> While indexes dramatically speed up `SELECT` queries, they slightly slow down data modification operations (`INSERT`, `UPDATE`, `DELETE`) because the database must update not only the table but also the index.",
                    "<strong>EXPLAIN Command:</strong> This is a powerful diagnostic tool. Prefixing your `SELECT` query with `EXPLAIN` shows you the 'execution plan' that the database will use. You can use it to verify if your indexes are being used effectively and identify performance bottlenecks."
                ],
                questions: [
                    { task: "1. Write a query to create an index on order_date.", query: "CREATE INDEX idx_order_date ON orders(order_date);", explanation: "This DDL (Data Definition Language) command creates a new index named `idx_order_date` on the `order_date` column of the `orders` table. This will significantly speed up any queries that filter or sort by this date column." },
                    { task: "2. Write a query to explain how the index improves query performance by checking the execution plan.", query: "EXPLAIN SELECT * FROM orders WHERE order_date > '2025-01-01';", explanation: "`EXPLAIN` shows the query execution plan. With an index, the output will show it can use 'idx_order_date' to quickly find the relevant rows (often a 'range' scan), which is much faster than a full 'table' scan that would be used otherwise." }
                ]
            },
            {
                topic: "Set 10: Complex Query Challenge",
                schema: "- orders(order_id, customer_id, order_date, amount)\n- customers(customer_id, customer_name, city)\n- products(product_id, product_name, price)\n- order_items(order_id, product_id, quantity)",
                concepts: [
                    "<strong>Problem Decomposition:</strong> The key to solving complex queries is to break the problem down into smaller, logical steps. Ask yourself: What is the final piece of information I need? What tables have this information? How are they related? What filtering is required? Do I need to group and aggregate data?",
                    "<strong>Combining Clauses:</strong> Complex queries are all about using multiple SQL clauses together in the correct logical order: `JOIN`s to link data, `WHERE` to filter it, `GROUP BY` to aggregate it, `HAVING` to filter the aggregates, `ORDER BY` to sort the final result, and `LIMIT` to restrict the output.",
                    "<strong>Mastering Functions:</strong> Effective use of date functions (like `DATE_SUB`), aggregate functions (`SUM`, `COUNT`), and sometimes subqueries or window functions is often necessary to solve these challenging problems.",
                    "<strong>Readability is Key:</strong> Use meaningful table aliases and consistent formatting (like indenting your clauses). A clean, readable query is much easier to write, understand, and debug."
                ],
                questions: [
                    { task: "1. Write a query to display the top 3 customers who spent the most in the last 6 months.", query: "SELECT c.customer_id, c.customer_name, SUM(o.amount) AS total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id WHERE o.order_date >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH) GROUP BY c.customer_id, c.customer_name ORDER BY total_spent DESC LIMIT 3;", explanation: "This query perfectly demonstrates combining clauses: `DATE_SUB` filters orders to the last 6 months in the `WHERE` clause. `JOIN` links customers to their orders. `GROUP BY` and `SUM` aggregate the spending per customer. `ORDER BY ... DESC` sorts them by the highest spending, and `LIMIT 3` selects only the top three." },
                    { task: "2. Write a query to display the most sold product by quantity.", query: "SELECT p.product_id, p.product_name, SUM(oi.quantity) AS total_quantity FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id, p.product_name ORDER BY total_quantity DESC LIMIT 1;", explanation: "This query joins the `products` and `order_items` tables to link product names with their sale quantities. It then groups the results by each product and calculates the `SUM` of the `quantity`. Finally, it orders the results in descending order of the total quantity and uses `LIMIT 1` to retrieve only the top product." }
                ]
            }
        ];
        
        // --- All the JavaScript functions and event listeners from the previous version remain here ---
        const mainContainer = document.querySelector('.main-container');
        const topicSelectionView = document.getElementById('topic-selection-view');
        const practiceView = document.getElementById('practice-view');
        const topicGrid = document.getElementById('topic-grid');
        const topicTitleEl = document.getElementById('topic-title');
        const schemaDisplayEl = document.getElementById('schema-display');
        const questionCounterEl = document.getElementById('question-counter');
        const taskDescEl = document.getElementById('task-description');
        const userQueryArea = document.getElementById('user-query-area');
        const queryCodeEl = document.getElementById('query-code');
        const explanationTextEl = document.getElementById('explanation-text');
        const feedbackContainer = document.getElementById('feedback-container');
        const feedbackTitle = document.getElementById('feedback-title');
        const feedbackList = document.getElementById('feedback-list');
        const progressBar = document.getElementById('progress-bar');
        const modal = document.getElementById('concepts-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');

        let currentTopicIndex = 0;
        let currentQuestionIndex = 0;

        function parseQuery(query) {
             const cleanedQuery = query.replace(/\s+/g, ' ').trim();
             const clauses = {};
             
             // A simplified regex approach for robustness
             const selectMatch = cleanedQuery.match(/select(.*?)from/i);
             if (selectMatch) clauses.select = selectMatch[1].trim();

             const fromMatch = cleanedQuery.match(/from(.*?)(?:inner join|left join|right join|where|group by|order by|limit|$)/i);
             if (fromMatch) clauses.from = fromMatch[1].trim();

             const joinMatch = cleanedQuery.match(/(?:inner join|left join|right join)(.*?)(?:on|where|group by|order by|limit|$)/i);
             if (joinMatch) clauses.join = joinMatch[1].trim();

             const onMatch = cleanedQuery.match(/on(.*?)(?:where|group by|order by|limit|$)/i);
             if (onMatch) clauses.on = onMatch[1].trim();
             
             const whereMatch = cleanedQuery.match(/where(.*?)(?:group by|order by|limit|$)/i);
             if (whereMatch) clauses.where = whereMatch[1].trim();
             
             const groupByMatch = cleanedQuery.match(/group by(.*?)(?:order by|limit|$)/i);
             if (groupByMatch) clauses['group by'] = groupByMatch[1].trim();

             const orderByMatch = cleanedQuery.match(/order by(.*?)(?:limit|$)/i);
             if (orderByMatch) clauses['order by'] = orderByMatch[1].trim();
             
             const limitMatch = cleanedQuery.match(/limit(.*?)$/i);
             if (limitMatch) clauses.limit = limitMatch[1].trim();
             
             return clauses;
        }

        function normalize(str) {
            if (!str) return '';
            return str.toLowerCase().replace(/\s*as\s/g, ' ').replace(/[`,();']/g, '').replace(/\s+/g, '');
        }

        function getAdvancedFeedback(userQuery, correctQuery) {
            const isDDL = correctQuery.trim().toLowerCase().startsWith('create') || correctQuery.trim().toLowerCase().startsWith('start transaction') || correctQuery.trim().toLowerCase().startsWith('explain');
            if(isDDL) {
                 const normalizedUser = userQuery.toLowerCase().replace(/\s+/g, ' ').replace(/;/g, '').trim();
                 const normalizedCorrect = correctQuery.toLowerCase().replace(/\s+/g, ' ').replace(/;/g, '').trim();
                 if (normalizedUser === normalizedCorrect) {
                     return { isCorrect: true, feedback: [] };
                 } else {
                     return { isCorrect: false, feedback: [`<li>ðŸ’¡ The entire statement seems incorrect. Please review the structure.</li>`] };
                 }
            }

            const userClauses = parseQuery(userQuery);
            const correctClauses = parseQuery(correctQuery);
            const feedback = [];
            let isCorrect = true;

            const allClauseKeys = ['select', 'from', 'join', 'on', 'where', 'group by', 'order by', 'limit'];
            
            for (const clause of allClauseKeys) {
                 const userVal = userClauses[clause];
                 const correctVal = correctClauses[clause];

                 if (!userVal && !correctVal) continue;

                 if (normalize(userVal) === normalize(correctVal)) {
                     if (userVal) feedback.push(`<li>âœ… Your <strong>${clause.toUpperCase()}</strong> clause looks correct.</li>`);
                 } else {
                     isCorrect = false;
                     if (correctVal && !userVal) feedback.push(`<li>ðŸ’¡ It looks like you're missing the <strong>${clause.toUpperCase()}</strong> clause.</li>`);
                     else if (userVal && !correctVal) feedback.push(`<li>ðŸ’¡ The <strong>${clause.toUpperCase()}</strong> clause isn't needed here.</li>`);
                     else feedback.push(`<li>ðŸ’¡ Check your <strong>${clause.toUpperCase()}</strong> clause.</li>`);
                 }
            }
            
            if (normalize(userQuery) === normalize(correctQuery)) isCorrect = true;
            if (isCorrect) feedback.length = 0;

            return { isCorrect, feedback };
        }

        function checkUserCode() {
            const userQuery = userQueryArea.value;
            if (!userQuery.trim()) return;
            const correctQuery = learningData[currentTopicIndex].questions[currentQuestionIndex].query;

            const { isCorrect, feedback } = getAdvancedFeedback(userQuery, correctQuery);

            feedbackContainer.style.display = 'block';
            if (isCorrect) {
                feedbackTitle.textContent = "âœ… Excellent! Your query is correct.";
                feedbackList.innerHTML = "";
                feedbackContainer.className = 'correct';
            } else {
                feedbackTitle.textContent = "ðŸ’¡ Here is an analysis of your query:";
                feedbackList.innerHTML = feedback.join('');
                feedbackContainer.className = 'incorrect';
            }
        }
        
        function loadQuestion() {
            const topic = learningData[currentTopicIndex];
            const question = topic.questions[currentQuestionIndex];
            
            mainContainer.style.opacity = 0;
            setTimeout(() => {
                practiceView.style.display = 'block';
                topicSelectionView.style.display = 'none';

                document.getElementById('answer-content').style.display = 'none';
                feedbackContainer.style.display = 'none';
                userQueryArea.value = '';

                topicTitleEl.textContent = topic.topic;
                schemaDisplayEl.textContent = topic.schema;
                questionCounterEl.textContent = `Question ${currentQuestionIndex + 1} of ${topic.questions.length}`;
                taskDescEl.textContent = question.task;
                queryCodeEl.textContent = question.query;
                explanationTextEl.innerHTML = question.explanation;

                const progress = ((currentQuestionIndex + 1) / topic.questions.length) * 100;
                progressBar.style.width = `${progress}%`;

                document.getElementById('prev-btn').style.visibility = currentQuestionIndex === 0 ? 'hidden' : 'visible';
                document.getElementById('next-btn').style.visibility = currentQuestionIndex === topic.questions.length - 1 ? 'hidden' : 'visible';
                
                mainContainer.style.opacity = 1;
            }, 300);
        }
        
        function loadTopics() {
            mainContainer.style.opacity = 0;
            setTimeout(() => {
                practiceView.style.display = 'none';
                topicSelectionView.style.display = 'block';
                topicGrid.innerHTML = '';
                learningData.forEach((topicData, index) => {
                    const card = document.createElement('div');
                    card.className = 'topic-card';
                    card.textContent = topicData.topic;
                    card.dataset.index = index;
                    card.addEventListener('click', () => {
                        currentTopicIndex = index;
                        currentQuestionIndex = 0;
                        loadQuestion();
                    });
                    topicGrid.appendChild(card);
                });
                mainContainer.style.opacity = 1;
            }, 300);
        }

        document.getElementById('toggle-concepts-btn').addEventListener('click', () => {
            const topic = learningData[currentTopicIndex];
            modalTitle.textContent = topic.topic;
            modalBody.innerHTML = `<ul>${topic.concepts.map(c => `<li>${c}</li>`).join('')}</ul>`;
            modal.classList.add('show');
        });
        modal.addEventListener('click', (e) => {
            if (e.target === modal || e.target.id === 'modal-close-btn') {
                modal.classList.remove('show');
            }
        });
        
        document.getElementById('check-code-btn').addEventListener('click', checkUserCode);
        document.getElementById('reveal-answer-btn').addEventListener('click', () => {
            document.getElementById('answer-content').style.display = 'block';
        });
        document.getElementById('next-btn').addEventListener('click', () => {
            if (currentQuestionIndex < learningData[currentTopicIndex].questions.length - 1) {
                currentQuestionIndex++;
                loadQuestion();
            }
        });
        document.getElementById('prev-btn').addEventListener('click', () => {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                loadQuestion();
            }
        });
        document.getElementById('back-to-topics-btn').addEventListener('click', loadTopics);

        loadTopics();
    </script>
</body>
</html>
